---
title: stdafx.h
date: 2015-12-17 10:51:19
tags: ["tech","技术","MFC"]
author: wangxiuwen
categories: ["技术"]
layout: post
---

目录http://my.oschina.net/u/1772925/blog/396347#OSC_h1_1http://my.oschina.net/u/1772925/blog/396347#OSC_h2_2http://my.oschina.net/u/1772925/blog/396347#OSC_h2_3http://my.oschina.net/u/1772925/blog/396347#OSC_h2_4

**stdafx.h**VC工程里面经常见到stdafx.h这个头文件，以前也没有特别注意，但是这个文件用不好经常会出错，所以就GOOGLE了一下，总算是弄清楚了。。。stdafx的英文全称为：Standard Application Framework Extensions（标准应用程序框架的扩展）。所谓**头文件预编译**，就是把一个工程(Project)中使用的一些MFC标准头文件(如Windows.H、Afxwin.H)预先编译，以后该工程编译时，不再编译这部分头文件，仅仅使用预编译的结果。这样可以加快编译速度，节省时间。**简介**预编译头文件通过编译stdafx.cpp生成，以工程名命名，由于预编译的头文件的后缀是“pch”，所以编译结果文件是projectname.pch。编译器通过一个头文件stdafx.h来使用预编译头文件。stdafx.h这个头文件名是可以在project的编译设置里指定的。编译器认为，所有在指令#include "stdafx.h"前的代码都是预编译的，它跳过#include "stdafx. h"指令，使用projectname.pch编译这条指令之后的所有代码。因此，**所有的MFC实现文件第一条语句都是：#include "stdafx.h"**。在它前面的所有代码将被忽略，所以其他的头文件应该在这一行后面被包含。否则，你将会得到“No such file or directory”这样让你百思不得其解的错误提示。**作用**stdafx.h中没有函数库，只是定义了一些环境参数，使得编译出来的程序能在32位的操作系统环境下运行。Windows和MFC的include文件都非常大，即使有一个快速的处理程序，编译程序也要花费相当长的时间来完成工作。由于每个.CPP文件都包含相同的include文件，为每个.CPP文件都重复处理这些文件就显得很傻了。为避免这种浪费，AppWizard和VisualC++编译程序一起进行工作，如下所示：　　◎AppWizard建立了文件stdafx.h，该文件包含了所有当前工程文件需要的MFCinclude文件。且这一文件可以随被选择的选项而变化。　　◎AppWizard然后就建立Stdafx.cpp。这个文件通常都是一样的。　　◎然后AppWizard就建立起工程文件，这样第一个被编译的文件就是stdafx.cpp。　　◎当VisualC++编译stdafx.cpp文件时，它将结果保存在一个名为stdafx.pch的文件里。(扩展名pch表示预编译头文件。)　　◎当VisualC++编译随后的每个.cpp文件时，它阅读并使用它刚生成的.pch文件。VisualC++不再分析Windowsinclude文件，除非你又编辑了stdafx.cpp或stdafx.h。在这个过程中你必须遵守以下规则：　　◎你编写的任何.cpp文件都必须首先包含stdafx.h。　　◎如果你有工程文件里的大多数.cpp文件需要.h文件，顺便将它们加在stdafx.h(后部)上，然后预编译stdafx.cpp。　　◎由于.pch文件具有大量的符号信息，它是你的工程文件里最大的文件。如果你的磁盘空间有限，你就希望能将这个你从没使用过的工程文件中的.pch文件删除。执行程序时并不需要它们，且随着工程文件的重新建立，它们也自动地重新建立。**原理**　　通俗一点说当我们使用AppWizard来自动生成某些项目的时候,系统会自动把所需要include的头文件在stdafx.h中先include一下,这样,我们只需要直接include这个stdafx.h文件即可.因为同一个项目中的不同源文件CPP都包含相同的include文件,这样,为每个.CPP文件都重复include这些文件就显得很傻了。当然如果你不用MFC的话就不用了。即：在每个.cpp文件中都include stdafx.h 就相当于包含了其他的如iostream.h等文件

